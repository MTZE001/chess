<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="utf-8"/>
<title>Chess Tutor ‚Äî Play</title>
<style>
  :root{ --muted:#9fbfd8; --accent:#19b5ff; }
  *{box-sizing:border-box}
  body{
    margin:0; min-height:100vh; font-family:Inter, Arial, sans-serif;
    background: linear-gradient(180deg,#041028,#071017);
    color:#e6f3ff; display:flex; flex-direction:column; align-items:center; gap:16px; padding:22px;
  }
  .topbar{width:100%; max-width:980px; display:flex; justify-content:space-between; align-items:center}
  .card{background:rgba(11,18,32,0.9); padding:10px 14px; border-radius:10px; border:1px solid rgba(255,255,255,0.02)}
  button{padding:8px 12px; border-radius:8px; border:none; cursor:pointer}
  #boardWrap{display:flex; gap:14px; align-items:flex-start; max-width:980px; width:100%;}
  /* ‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô: ‡∏Ç‡∏≠‡∏ö‡πÄ‡∏•‡πá‡∏Å‡∏•‡∏á, hover ‡πÄ‡∏ö‡∏≤‡∏•‡∏á */
  #board{display:grid; grid-template-columns:repeat(8,64px); grid-template-rows:repeat(8,64px); border-radius:10px; overflow:hidden; box-shadow:inset 0 0 0 1px rgba(255,255,255,0.02)}
  .tile{width:64px; height:64px; display:flex; align-items:center; justify-content:center; font-size:30px; user-select:none;
        transition: transform .10s ease, border-color .12s ease, box-shadow .12s ease, background .12s ease;
        border:1px solid transparent; box-sizing:border-box; cursor:pointer}
  .tile:hover{transform:translateY(-2px)}
  .pieceIcon{filter:drop-shadow(0 3px 6px rgba(0,0,0,0.55)); font-size:30px}
  .hud{display:flex; flex-direction:column; gap:10px; min-width:220px}
  .stat{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.04)); padding:10px; border-radius:8px}
  .hint{color:var(--muted); font-size:13px}
  /* ‡πÑ‡∏Æ‡πÑ‡∏•‡∏ï‡πå‡∏Ç‡∏≠‡∏ö (‡πÄ‡∏ö‡∏≤) */
  .cyan{box-shadow:0 0 8px 2px rgba(25,181,255,0.18); border-color:cyan !important}
  .captured-fx{position:fixed; inset:0; pointer-events:none; display:flex; align-items:center; justify-content:center; font-size:28px; color:#7ff0ff; opacity:0; transition:opacity .35s}
  .captured-fx.show{opacity:1}
</style>
</head>
<body>
  <div class="topbar" style="max-width:980px; width:100%">
    <div class="card">
      <strong>Chess Tutor ‚Äî ‡πÑ‡∏•‡πà‡∏à‡∏±‡∏ö‡∏´‡∏°‡∏≤‡∏Å‡∏î‡∏≥</strong>
      <div class="hint" style="margin-top:6px; font-size:13px">‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢: ‡∏Å‡∏¥‡∏ô‡∏´‡∏°‡∏≤‡∏Å‡∏î‡∏≥‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ‚Üí ‡πÄ‡∏Å‡∏°‡∏à‡∏∞‡∏™‡∏∏‡πà‡∏°‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ä‡∏ô‡∏∞</div>
    </div>

    <div style="display:flex; gap:8px;">
      <button onclick="location.href='select.html'">üîÅ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏°‡∏≤‡∏Å</button>
      <button onclick="location.href='settings.html'">‚öôÔ∏è ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤</button>
      <button onclick="resetGame()" style="background:linear-gradient(90deg,#ff9a19,#ffd86b);">‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡πÄ‡∏Å‡∏°</button>
    </div>
  </div>

  <div id="boardWrap" style="max-width:980px; width:100%">
    <div id="board" class="card" role="grid" aria-label="chess board"></div>

    <div class="hud">
      <div class="stat"><strong>‡∏´‡∏°‡∏≤‡∏Å‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì:</strong> <span id="myType"></span></div>
      <div class="stat"><strong>‡∏´‡∏°‡∏≤‡∏Å‡∏î‡∏≥‡πÄ‡∏´‡∏•‡∏∑‡∏≠:</strong> <span id="enemiesLeft">0</span></div>
      <div class="stat"><strong>‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥</strong><div class="hint" id="hint">‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ï‡∏±‡∏ß‡∏´‡∏°‡∏≤‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å ‚Üí ‡πÑ‡∏Æ‡πÑ‡∏•‡∏ï‡πå‡∏ä‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏î‡∏¥‡∏ô‡πÑ‡∏î‡πâ (‡∏Ç‡∏≠‡∏ö‡∏ü‡πâ‡∏≤) ‚Üí ‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ä‡πà‡∏≠‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏î‡∏¥‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡∏Å‡∏¥‡∏ô</div></div>
    </div>
  </div>

  <div id="capturedFx" class="captured-fx"> </div>

<script>
// ‡πÑ‡∏≠‡∏Ñ‡∏≠‡∏ô + ‡πÇ‡∏´‡∏•‡∏î‡∏ä‡∏ô‡∏¥‡∏î‡∏´‡∏°‡∏≤‡∏Å‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô (‡πÑ‡∏°‡πà‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï pawn)
const icons = { king:"‚ôî", queen:"‚ôï", rook:"‚ôñ", bishop:"‚ôó", knight:"‚ôò", pawn:"‚ôô" };
let myType = localStorage.getItem('selectedPiece') || 'knight';
if(myType === 'pawn'){ myType = 'knight'; localStorage.setItem('selectedPiece', myType); }
document.getElementById('myType').textContent = myType.toUpperCase();

// ‡∏™‡∏µ‡∏à‡∏≤‡∏Å settings
let lightColor = localStorage.getItem('boardLight') || '#f0f0f0';
let darkColor  = localStorage.getItem('boardDark')  || '#4a4a4a';
let defaultBorder = localStorage.getItem('boardBorder') || 'transparent';

// ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏Å‡∏°
let pieces = [];               // {x,y,type,owner:'player'|'enemy'}
let selectedIndex = null;
let highlighted = [];
const boardEl = document.getElementById('board');
const enemiesLeftEl = document.getElementById('enemiesLeft');
const capturedFx = document.getElementById('capturedFx');

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ä‡πà‡∏ß‡∏¢
function tileIndex(x,y){ return pieces.findIndex(p=>p.x===x && p.y===y); }
function pathClear(p, tx, ty){
  const dx = tx - p.x, dy = ty - p.y;
  const sx = Math.sign(dx), sy = Math.sign(dy);
  let cx = p.x + sx, cy = p.y + sy;
  while(cx !== tx || cy !== ty){
    if(tileIndex(cx,cy) !== -1) return false;
    cx += sx; cy += sy;
  }
  return true;
}

// ‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô
function validMove(p, x, y){
  if(x<0||x>7||y<0||y>7) return false;
  if(p.x===x && p.y===y) return false;
  const dx = x - p.x, dy = y - p.y;
  switch(p.type){
    case 'king': return Math.max(Math.abs(dx),Math.abs(dy))===1;
    case 'queen': return (dx===0||dy===0||Math.abs(dx)===Math.abs(dy)) && pathClear(p,x,y);
    case 'rook': return (dx===0||dy===0) && pathClear(p,x,y);
    case 'bishop':
      // ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡πÅ‡∏ô‡∏ß‡∏ó‡πÅ‡∏¢‡∏á ‡πÅ‡∏•‡∏∞‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏ß‡πà‡∏≤‡∏á ‡πÅ‡∏•‡∏∞‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏µ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡∏ö‡∏¥‡∏ä‡∏≠‡∏õ (‡πÇ‡∏î‡∏¢‡∏´‡∏•‡∏±‡∏Å‡πÅ‡∏•‡πâ‡∏ß diagonal ‡∏à‡∏∞‡∏≠‡∏¢‡∏π‡πà‡∏™‡∏µ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß)
      if(Math.abs(dx)!==Math.abs(dy)) return false;
      // (‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ô) ‡∏ö‡∏¥‡∏ä‡∏≠‡∏õ‡∏à‡∏∞‡∏≠‡∏¢‡∏π‡πà‡∏ö‡∏ô‡∏™‡∏µ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡πÄ‡∏™‡∏°‡∏≠‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡πÅ‡∏¢‡∏á ‡πÅ‡∏ï‡πà‡πÄ‡∏£‡∏≤‡∏£‡∏±‡∏Å‡∏©‡∏≤‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô:
      if(((p.x + p.y) % 2) !== ((x + y) % 2)) return false;
      return pathClear(p,x,y);
    case 'knight': return (Math.abs(dx)===2&&Math.abs(dy)===1)||(Math.abs(dx)===1&&Math.abs(dy)===2);
    case 'pawn': return dx===0 && dy===-1;
    default: return false;
  }
}

// ‡∏™‡∏∏‡πà‡∏°‡∏®‡∏±‡∏ï‡∏£‡∏π ‡πÇ‡∏î‡∏¢‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô bishop ‡πÉ‡∏´‡πâ‡πÄ‡∏Å‡∏¥‡∏î‡∏ö‡∏ô‡∏™‡∏µ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö player (‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏à‡∏±‡∏ö‡πÑ‡∏î‡πâ)
function spawnEnemies(){
  const count = 4 + Math.floor(Math.random()*5); // 4..8
  const possible = ['pawn','rook','bishop','knight','queen'];
  const player = pieces.find(p=>p.owner==='player');
  const playerParity = (player.x + player.y) % 2;

  let placed = 0, attempts = 0;
  while(placed < count && attempts < 600){
    attempts++;
    let x = Math.floor(Math.random()*8);
    let y = Math.floor(Math.random()*8);
    if(pieces.some(p=>p.x===x && p.y===y)) continue;
    let t = possible[Math.floor(Math.random()*possible.length)];

    if(t === 'bishop'){
      // ‡∏´‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏µ parity ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö player
      if(((x+y) % 2) !== playerParity){
        // try to find one matching parity
        let found = false;
        for(let r=0; r<60; r++){
          const nx = Math.floor(Math.random()*8);
          const ny = Math.floor(Math.random()*8);
          if(pieces.some(p=>p.x===nx && p.y===ny)) continue;
          if(((nx+ny)%2) === playerParity){
            x = nx; y = ny;
            found = true; break;
          }
        }
        if(!found){
          // fallback ‚Äî convert to pawn to avoid blocking
          t = 'pawn';
        }
      }
    }

    if(pieces.some(p=>p.x===x && p.y===y)) continue;
    pieces.push({x,y,type:t, owner:'enemy'});
    placed++;
  }
}

// ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°
function initGame(){
  pieces = [];
  // ‡∏ß‡∏≤‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á
  pieces.push({x:4, y:4, type: myType, owner:'player'});
  spawnEnemies();
  selectedIndex = null;
  highlighted = [];
  draw();
  updateHUD();
}

// ‡∏ß‡∏≤‡∏î‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô + ‡∏ä‡∏¥‡πâ‡∏ô
function draw(){
  boardEl.innerHTML = '';
  for(let y=0;y<8;y++){
    for(let x=0;x<8;x++){
      const t = document.createElement('div');
      t.className = 'tile';
      t.dataset.x = x; t.dataset.y = y;
      t.style.background = ((x+y)%2===0) ? (localStorage.getItem('boardLight') || '#f0f0f0') : (localStorage.getItem('boardDark') || '#4a4a4a');
      t.style.borderColor = localStorage.getItem('boardBorder') || 'transparent';
      t.style.borderWidth = '1px'; // ‡∏Ç‡∏≠‡∏ö‡∏ö‡∏≤‡∏á‡∏•‡∏á

      const idx = tileIndex(x,y);
      if(idx !== -1){
        const p = pieces[idx];
        const span = document.createElement('div');
        span.className = 'pieceIcon';
        span.textContent = icons[p.type];
        span.style.transform = p.owner==='enemy' ? 'scale(.95)' : 'scale(1.05)';
        span.style.opacity = p.owner==='enemy' ? '0.95' : '1';
        if(p.owner === 'enemy') span.style.color = '#0a0a0a';
        t.appendChild(span);
      }
      t.addEventListener('click', ()=>onTileClick(x,y));
      boardEl.appendChild(t);
    }
  }
}

// ‡πÑ‡∏Æ‡πÑ‡∏•‡∏ï‡πå
function showHighlights(){
  clearHighlights();
  if(selectedIndex === null) return;
  const p = pieces[selectedIndex];
  const tiles = boardEl.children;
  for(let i=0;i<tiles.length;i++){
    const x = i%8, y = Math.floor(i/8);
    if(validMove(p,x,y)){
      const t = tiles[i];
      t.classList.add('cyan');
      highlighted.push(t);
    }
  }
}
function clearHighlights(){ highlighted.forEach(t=>t.classList.remove('cyan')); highlighted = []; }

function showCaptureFx(){ capturedFx.classList.add('show'); setTimeout(()=>capturedFx.classList.remove('show'),600); }

// ‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ö‡∏ô‡∏ä‡πà‡∏≠‡∏á
function onTileClick(x,y){
  const found = tileIndex(x,y);

  // ‡∏ñ‡πâ‡∏≤‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ä‡∏¥‡πâ‡∏ô‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô -> ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å/‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å
  if(found !== -1 && pieces[found].owner === 'player'){
    if(selectedIndex === found){ selectedIndex = null; clearHighlights(); return; }
    selectedIndex = found; showHighlights(); return;
  }

  // ‡∏ñ‡πâ‡∏≤‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ä‡∏¥‡πâ‡∏ô‡∏®‡∏±‡∏ï‡∏£‡∏π‡∏Ç‡∏ì‡∏∞‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô ‡πÅ‡∏•‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á -> ‡∏à‡∏±‡∏ö
  if(found !== -1 && pieces[found].owner === 'enemy' && selectedIndex !== null){
    const playerObj = pieces[selectedIndex];
    if(validMove(playerObj, x, y)){
      // ‡∏•‡∏ö‡∏®‡∏±‡∏ï‡∏£‡∏π‡∏Å‡πà‡∏≠‡∏ô (‡∏´‡∏≤ index ‡πÉ‡∏´‡∏°‡πà ‡πÄ‡∏û‡∏£‡∏≤‡∏∞ array ‡∏≠‡∏≤‡∏à‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô)
      const enemyIdx = tileIndex(x,y);
      if(enemyIdx !== -1 && pieces[enemyIdx].owner === 'enemy'){
        pieces.splice(enemyIdx, 1);
        // ‡∏¢‡πâ‡∏≤‡∏¢‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô (playerObj ‡∏≠‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏á‡∏¢‡∏±‡∏á‡∏Ñ‡∏á‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á)
        playerObj.x = x; playerObj.y = y;
        selectedIndex = null; clearHighlights();
        showCaptureFx();
        draw(); updateHUD(); checkWin();
      }
    }
    return;
  }

  // ‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ä‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á: ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÅ‡∏•‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á -> ‡∏¢‡πâ‡∏≤‡∏¢
  if(found === -1 && selectedIndex !== null){
    const p = pieces[selectedIndex];
    if(validMove(p, x, y)){
      p.x = x; p.y = y;
      selectedIndex = null; clearHighlights();
      draw(); updateHUD(); checkWin();
    }
    return;
  }

  // ‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ä‡∏¥‡πâ‡∏ô‡∏®‡∏±‡∏ï‡∏£‡∏π‡∏Ç‡∏ì‡∏∞‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å -> ‡πÑ‡∏°‡πà‡∏ó‡∏≥‡∏≠‡∏∞‡πÑ‡∏£
}

// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï HUD
function updateHUD(){
  const enemies = pieces.filter(p=>p.owner==='enemy').length;
  enemiesLeftEl.textContent = enemies;
}

// ‡πÄ‡∏ä‡πá‡∏Å‡∏ä‡∏ô‡∏∞
function checkWin(){
  const remaining = pieces.filter(p=>p.owner==='enemy').length;
  updateHUD();
  if(remaining === 0){
    document.getElementById('hint').textContent = '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡∏Å‡∏¥‡∏ô‡∏´‡∏°‡∏≤‡∏Å‡∏î‡∏≥‡∏´‡∏°‡∏î‡πÅ‡∏•‡πâ‡∏ß ‚Äî ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏∏‡πà‡∏°‡πÉ‡∏´‡∏°‡πà...';
    setTimeout(()=>{ initGame(); document.getElementById('hint').textContent = '‡∏™‡∏∏‡πà‡∏°‡πÉ‡∏´‡∏°‡πà‡πÅ‡∏•‡πâ‡∏ß! ‡πÑ‡∏•‡πà‡∏à‡∏±‡∏ö‡∏ï‡πà‡∏≠‡πÄ‡∏•‡∏¢'; }, 900);
  }
}

function resetGame(){ initGame(); }

// ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°
initGame();

// ‡∏ñ‡πâ‡∏≤‡πÑ‡∏õ‡πÅ‡∏Å‡πâ‡∏Ñ‡πà‡∏≤ settings ‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤ ‡πÉ‡∏´‡πâ‡∏£‡∏µ‡πÄ‡∏ü‡∏£‡∏ä‡∏™‡∏µ/‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô
window.addEventListener('focus', ()=>{
  draw(); updateHUD();
});
</script>
</body>
</html>
